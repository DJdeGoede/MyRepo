Linux: Shells and processes
===========================

Command execution process flow
------------------------------

     Keyboard  ->  terminal emulator  -> shell 
                                          |
                                          v
screen <- terminal emulator <- shell <- kernel

Shell types
-----------
When you use the keyboard to type in commands into a terminal window, such as 
GNOME Terminal, these commands are translated by the shell into ones and zeroes 
and sent to the kernel which then processes them. When the kernel finishes, 
it sends the data back to the shell which translates the output back into text 
which is displayed in the terminal emulator and output on the screen. 

A shell allows you to execute operating system commands. 
When a command is entered into the terminal, the shell checks to see 
- if it's a built-in first, and if so, executes it. 
- If it's not built-in, it will see if it's an alias of another command, 
  configured by the OS or another user. 
- If it's not built-in, or an alias, it will look for the command on the disk 
  and try to execute it there. 
- If it doesn't exist, it will say "command not found." 

There is a standard for Unix-like operating systems called POSIX. 
If you want to write your shell scripts to be portable, it may be advantageous 
to write your shell scripts in a POSIX-compliant manner. 

One of the first shells was the Bourne Shell, which came in out 1977. 
It was fairly basic and POSIX-compliant. Bill Joy one of the founders of 
Sun Microsystems wrote csh or the C Shell, which resembles the C language. 
The Bourne Shell won out in popularity, and it's not recommended that we write 
shell scripts in csh anymore. In 1983 ksh or the Korn Shell was introduced 
adding job control and command history, which we'll talk about later in this course. 

Later, Bash was introduced as a replacement for Bourne. If started with the correct 
options, Bash is mostly POSIX compliant. Bash includes most of the original 
functionality of the Bourne Shell, most of the additions of Korn Shell, as well 
as some additional functionality of its own. 
Bash is probably the default shell on more Unix systems than any other shell. 
Most systems now run Bash 4. 

Another popular shell is Dash. Dash is the Debian version of the Ash Shell 
from NetBSD Unix. Its biggest claim to fame is that it's smaller and uses less 
memory than Bash. Although it's popular on Debian-based distributions it isn't 
easily installed on CentOs 7. 

If interactivity is your interest you may want to check out Fish. 
Fish has some interesting features like syntax highlighting on the command line 
so you know if you've typed in the correct command. It also suggests commands, 
options and paths. 

The last shell we'll talk about is Zsh. Zsh has virtually identical features 
to Bash, but is enhanced in several ways including better command and option 
completion and better pattern matching. 

Most of these shells can be installed using yum. For instance, to install Zsh, 
you'd type into a terminal:
- sudo apt install -y zsh 

to change your shell, run the change shell command and follow the prompts. 
Be sure to type in the whole path to the desired shell when prompted. 
You type in 'chsh' and hit Enter. If will prompt you for the desired shell. 
To use the new shell, you'll have to log out and log back in again. 
There are a lot of interesting shell options in Linux. For interactive use, 
you should try out the different shells to see what you like. 
However, if you create shell scripts to automate tasks, the choice of a shell 
becomes very important as the syntax of built-in design elements like loops, 
conditionals and arrays will change depending on which shell you use. 
Shell scripts written for one shell may not be compatible with another. 
I would recommend at this time to keep using Bash and later explore other shells.

Variables and shell environment
===============================
There are two types of variables accessible in a shell session. 

- Environmental variables: defined for the current shell and inherited by 
  any child processes or child shells. 

- Shell variables: contained exclusively within the shell in which they were 
  defined. They are often used to keep track of data like the current 
  working directory. 

To see the environmental variables in a terminal, type in 'printenv' and hit Enter. 
If you want to get the value of an individual variable, you can specify it. 
Type in printenv, and for instance type in capital SHELL and hit Enter. 
Another way is to use the echo command to print the value by typing in 'echo $SHELL' 
and hit Enter. 

To see the shell variables we use the set command. Type in 'set' and hit Enter. 
By default the set command shows shell functions as well as variables, 
which can be quite long. 

To change the behavior of set do posix mode, which doesn't show functions. Use the dash O posix option. 
Type in 'set -o posix' and hit Enter. Now type in set again and let's pipe it to less. 
Here we can see all of the shell variables without the shell functions. 

To show the difference between environmental variables and shell variables, let's set a variable in 
our shell. Press q to quit, and then type in 'VAR=TEST' and hit Enter. 
Now let's grep the output of set to view it. 
Type in 'set | grep VAR' and hit Enter. And there it is. Now let's grep the output of printenv. 

Type in 'printenv | grep VAR' and hit Enter. 
And we can see that a variable is not a part of the environment. 
To turn a shell variable into an environmental variable we can just export it. 
Let's export the variable we just set. Type in export VAR and hit Enter. Verify with printenv. 
Type in printenv | grep VAR and hit Enter. And we can that our variable is now part of the environment. 
It isn't persistent since we didn't save it in a file. If we rebooted, it would disappear. 

To unset environmental variables, we can use the export command again. 
Type in 'export -n VAR' and hit Enter. 
We can verify this by typing in printenv | grep VAR and hit Enter. 
We can see that the variable is no longer a part of the environment. 
To unset shell variables, we can use the unset command. 
Type in 'unset VAR' and hit Enter. 

Earlier we changed a shell option by turning on posix mode by typing in set -o posix. 
We can view all shell options by typing in set -o and hit Enter. To unset any shell option, 
use +o. For instance, to unset posix mode, type in 'set +o posix' and hit Enter. 
And we can verify this again by typing in set -o. We can change the value of environment and 
shell variables by setting them. 

We can also change bash options using the set command. However, these values only survive for 
the current login session. To make them persistent, we need to add them to one of the bash startup files. 
Bash stores it's configuration settings in multiple startup files. Different files are processed, 
depending on how the shell starts:

1. /etc/profile
When we log into Linux by typing in a password, Linux first executes the etc profile ..

2. /etc/profile.d
.. which in turn executes scripts in /etc/profile.d. These two items are the systemwide file and 
directories holding our environment and shell variables. 

3. ~/.bash_profile
Then bash executes the ._profile in the user's home directory, which holds environment and shell 
variables specific to the user. 

4. ~/.bashrc
The local .bash_profile in turn executes the local .bashrc file which holds aliases and bash functions. 
In CentOS the local .bashrc also executes the systemwide /etc/bashrc file, which holds systemwide aliases 
and functions. When that is complete, it returns control back to the local .bashrc file in the user's 
home directory. The local .bashrc file holds aliases and functions specific to the user. 

Once all of this is done, the user logs in. If a user is already logged in and executes a shell script, 
it's executed in a shell, but it's not a login shell. Also, if a user is logged into the GUI and starts 
a shell, it's not a login shell. Generally speaking, a login shell requires entering a password or 
providing a login key. For non-login shells, only the users .bashrc gets run. Again on CentOS, the local 
.bashrc file executes the global /etc/bashrc file, which holds systemwide aliases and functions. 
Then it returns control back to the local .bashrc file again and finishes processing it. This file 
should contain aliases and functions specific to the user. 

Once this is all done, the shell starts. 

In summary, the various bash profile files are for environmental and shell variables useful for 
interactive logins:
- If you want to set a variable for all users, set it in:
	- /etc/profile    or
	- /etc/profile.d 
- If you want to set a variable specific to a user, change it in: 
	- the user's .bash_profile. 
- If you want to add aliases or functions for all users:
	- add them to the /etc/bashrc. 
- If you want to add aliases or functions specific to a user: 
	- add them to the user's .bashrc. 
	
! - It's important to note that when you add aliases or functions to the user's .bashrc file, be sure 
to add them to the end of the file after /etc/bashrc has been called to override systemwide 
system aliases and functions.

Shell tips and tricks
=====================
It helps to know some tips and tricks when using the Linux shell. 
Let's talk about some pathname shortcut locations, or pathname expansions. 

pwd 
To verify where we are in the file system, type in 'pwd' into a terminal. This shows that we're in our home directory. 

cd ..
Now type in 'cd ..' and type in 'pwd' again to verify. Typing in cd .. takes us to our parent directory 
which is one higher in the directory tree than where we were. 

cd .
Another shortcut is cd . Type in cd . and hit Enter. Now type in 'pwd' to verify, and we can see that 
we are in the same location. The single dot is a shortcut to our current directory. The dot isn't very 
useful for the cd command, but often we want to copy files to our current directory. 
Instead of typing in the whole path, we could just use dot. 

cd ~
Now type in cd ~ and hit Enter, and then type in pwd to verify our path. The tilde takes us to our 
home directory. 

cd -
Now type in cd - and hit Enter. We don't have to type pwd after cd - as it tells us where we are. 
Type in cd - again, and you can see that it takes us back to our home directory. cd - just takes you 
to the previous directory or the last one you were in. 

Using pathname expansion can be a great time-saver for Linux users. 

clear (or <ctrl><l>)
If you want to clear the screen, type in clear. 

cmd completion (<tab> once for completion or twice to see choice)
--------------
Another productivity trick for Bash is command line completion. To set this up, let's go back to 
our home directory by typing in cd ~ and then typing in ls to get a directory listing. 
To use command line completion, we'll use our Tab key. The purpose of the Tab key is to complete the 
line for us so we don't have to type it in again. Type in cd M and then hit the Tab key, and you'll see 
that the line is completed for us. If we have one directory starting with a capital m, Bash will complete 
the line for us. However, if there's more than one possible choice Bash will give us an option, but only 
after we've pressed Tab twice. Let's backspace our line all the way to the beginning. And then type in 
cd D and hit your Tab key twice. You see that we have three different choices: Desktop, Documents and 
Downloads. Bash wants us to type in a unique character, so type in the e and hit your Tab key again. 
And now it can complete the line. 

moving in a cmd line (<Home>, <End>, <alt><b>, <alt><f>
--------------------
To quickly move between the beginning and end of the line, just use the Home and End keys. 
So, press the Home key, and you can see that your cursor moves to the beginning. End key takes you to 
the end. If you just want to move one word at a time, you can press alt + b to go backwards and 
alt + f to go forwards.

Remark:
<ctrl><u> removes everything before the cursor
<ctrl><k> removes everything after the cursor

Shell history tricks
====================

The Shell keeps track of the command history. Useful commands/variables:

up/down : browse through history
history	: show all commands you used (default set to 500 or 1000 items depending on config)
!!    	: Bring back the entire last line from the history
sudo !!	: Run the previous command with prefix 'sudo ' (run previous command as super user)
!-<nr>  : Show x-th command from the bottom (!-4 : execute the 4th command before the last one)
!<nr>   : Run a specific command (!73 : run command from history list with nr 73)
!<text> : find command starting with <text>
!*		: use arguments from previous line
			You can use it within a command line as variable:
			1. printenv HISTCONTROL    (parameter = HISTCONTROL)
			2. export !*="ignoreboth"  (will run: export HISTCONTROL="ignoreboth")

ctrl+r	: reverse i-search (= history search mode)
			- type text and command starting with that text show up
				- enter			  : run line
				- arrow left/right: edit it
				- ctrl+r		  : continue search 

Configure shell history
=======================

Control the history config via shell variables.
- Use  export <variable>=<value>  to set it
- Use  export <variable>=""       to unset it

You can use:
- export HISTCONTROL=ignorespace	: if command line starts with space don't store it in the history
- export HISTCONTROL=ignoredups 	: ignore new duplicate entries
- export HISTCONTROL=erasedups 		: remove existing duplicates from history
- 
Combine them:  export HISTCONTROL="erasedups:ignorespace"

There are some lines that you might never want to have in the history, such as the history command itself. 
To keep certain lines from being recorded, we can place them in the hist ignore variable. 
Type in 'export HISTIGNORE="history*"; this is going to ignore any lines that start with the word history 
and are followed by any number of characters, hit enter. We can test this by typing in history again, 
and hit enter. Let's test this by typing in history again, and hit enter. We can see that there's no lines 
being added for the command history.

We can also add several patterns to the HISTIGNORE variable by separating them with a colon. 
Type in 'export HISTIGNORE="history*:ls*" and hit enter. Now it should ignore any lines starting with 
the word history or the word ls. 

If we want a better log of our commands and history, including time stamps, we can change the variable 
HISTTIMEFORMAT. Type in 'export HISTTIMEFORMAT="%h %d %H:%M:%S> ". What this does is add the date and time 
to your history items. Type in history and hit enter. To get the list of possible variables, check demand 
page for strftime, by typing in 'man strftime' and hitting enter. 
You can see the variables that are available to customize your date and time format. Press q to quit. 

By default our history file's 1,000 lines. If you'd like to increase this, we can change the value of 
the HISTSIZE variable, type in 'export HISTSIZE=10000' and hit enter. If you wanted it unlimited, 
we can set it to a negative value, such as -1. 

If we want to turn off recording of our history, we'd set it to zero, when we exit our shell, 
our history is saved and the file named .bash_history, in our home directory. We can choose how many lines
are saved in this file by changing the HISTFILESIZE variable, type in 'export HISTFILESIZE equals 10,000. 
Set this to zero if you want to turn off saving of your command history on the disk. 
All of these changes we've made so far are just for our current login session, to make them persistent 
so they're set when we log in, we need to add them to our bash profile using a text editor, I'll use VI for this. Type in vi space tilda, slash dot bash underscore profile and hit enter. We'll want to go down to the bottom of the file, go into insert mode by pressing the i, or the insert key and hit enter, now let's add a few of our variables. Type in HISTCONTROL equals double quote, erase, dups, colon, ignore space, double quote. We can also add a HISTIGNORE in here by typing HISTIGNORE equals double quote, history, asterisk, double quote. You can add the other variables as well if you'd like. Now let's save this file by pressing escape, colon, wq and hit enter. We can change other attributes of the shell by entering them in the bash profile as well.

To undo the changes just send an empty string to the variable, like 'HISTIGNORE=""'





